// mid-level FSM that handles the enter/exit signals generated by cars passing sensors.
// enter/exit signals are only active for one clock cycle. Built in pedestrian filter.
// inputs: clock, reset, 2-bit sensor [outer, inner]
// outputs: Enter, Exit
module photoSensor (Clk, Rst, Sensor, Enter, Exit, HEX0, HEX1, HEX2, HEX3, HEX4, HEX5);
	// Declare signals Clock and Reset
	input logic  Clk, Rst;
	// Declare sensor signals (SW1, SW0)
	input logic  [1:0] Sensor;
	// Declare HEX displays
	output logic [6:0] HEX0, HEX1, HEX2, HEX3, HEX4, HEX5;
	// Declare Enter and Exit signals
	output logic Enter, Exit;
	// Create counter
	logic [4:0] counter;
	
	// Create enter exit handler module
	enter_exit_handler dut (.clk(Clk), .reset(Rst), .counterstate(counter), .HEX0(HEX0), .HEX1(HEX1), .HEX2(HEX2), .HEX3(HEX3), .HEX4(HEX4), .HEX5(HEX5));
	
	//define state variables
	enum { empty, oBlocked, iBlocked, both} ps, ns;
	
	// next state logic
	always_comb begin
		// case dependent on present state
		case(ps)
			// empty case
			empty: begin
				// if sensor is both blocked set next state to both
				if (Sensor == 2'b11)		ns = both;
				// else if inside blocked set next to inside blocked
				else if (Sensor == 2'b01)	ns = iBlocked;
				// else if outside blocked set next to outside blocked
				else if (Sensor == 2'b10)	ns = oBlocked;
				// else set next to empty state
				else						ns = empty;
			end
			
			oBlocked: begin
				// if sensor is both blocked set next state to both
				if (Sensor == 2'b11)		ns = both;
				// else if inside blocked set next to inside blocked
				else if (Sensor == 2'b01)	ns = iBlocked;
				// else if outside blocked set next to outside blocked
				else if (Sensor == 2'b10)	ns = oBlocked;
				// else set next to empty state
				else						ns = empty;
			end
			
			iBlocked: begin
				// if sensor is both blocked set next state to both
				if (Sensor == 2'b11)		ns = both;
				// else if inside blocked set next to inside blocked
				else if (Sensor == 2'b01)	ns = iBlocked;
				// else if outside blocked set next to outside blocked
				else if (Sensor == 2'b10)	ns = oBlocked;
				// else set next to empty state
				else						ns = empty;
			end
			
			both: begin
				// if sensor is both blocked set next state to both
				if (Sensor == 2'b11)		ns = both;
				// else if inside blocked set next to inside blocked
				else if (Sensor == 2'b01)	ns = iBlocked;
				// else if outside blocked set next to outside blocked
				else if (Sensor == 2'b10)	ns = oBlocked;
				// else set next to empty state
				else						ns = empty;
			end
			// default set the next state to empty
			default: 						ns = empty;
		endcase
	end // comb_begin
	
	// at the next rising edge of the clock
	always_ff @(posedge Clk) begin
		// if the reset is high, set present state to empty
		if (Rst)
			ps <= empty;
		// else set it to next state
		else
			ps <= ns;
	end
	
	// at the next rising edge of the clock
	always_ff @(posedge Clk) begin
		// if reset is high set counter to 0
		if (Rst)
			counter <= 0;

		// Entering conditions
		else if ((ns == iBlocked) & (ps == both) & counter < 16) begin
		    counter++;
			Enter = 1;
			Exit = 0;
		end
		
		// Exiting conditions
		else if ((ns == oBlocked) & (ps == both) & counter > 0) begin
			counter--;
			Enter = 0;
			Exit = 1;
		end
		
		// Standby conditions
		else begin
			Enter = 0;
			Exit = 0;
		end
	end
endmodule // photoSensor

module PhotoSensor_tb();

	// define signals
	logic	clk, reset;
	logic [9:0] SW;
	logic [6:0] HEX0, HEX1, HEX2, HEX3, HEX4, HEX5;
	logic 		Enter, Exit;

	// define parameters
	parameter T = 20;
	
	// instantiate module
	photoSensor dut (.Clk(clk), .Rst(reset), .Sensor(SW[1:0]), .Enter(Enter), .Exit(Exit), .HEX0(HEX0), .HEX1(HEX1), .HEX2(HEX2), .HEX3(HEX3), .HEX4(HEX4), .HEX5(HEX5));
	
	// define simulated clock
	initial begin
		clk <= 0;
		forever #(T/2) clk <= ~clk;
	end  // initial clock
	
	initial begin
		SW[9:0] <= 1; reset <= 1; 	@(posedge clk);
		SW[9:0] <= 0; reset <= 0;	@(posedge clk);

		// Entering Test
		for (int i = 0; i < 20; i++) begin
			SW[1:0] 	<=  2'b10; @(posedge clk);
			SW[1:0] 	<=  2'b11; @(posedge clk);
			SW[1:0] 	<=  2'b01; @(posedge clk);
			SW[1:0]  <=  2'b00; @(posedge clk);
		end // Looped 20x

		// Exiting Test
		for (int i = 0; i < 20; i++) begin
			SW[1:0] 	<=  2'b01; @(posedge clk);
			SW[1:0] 	<=  2'b11; @(posedge clk);
			SW[1:0] 	<=  2'b10; @(posedge clk);
			SW[1:0] 	<=  2'b00; @(posedge clk);
		end // Looped 20x

		$stop;
	end
	
endmodule  // DE1_SoC_tb